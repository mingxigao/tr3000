name: OpenWrt – TR3000 v1 DTS 112M UBI

run-name: >-
  ${{ github.event_name == 'workflow_dispatch'
      && format('TR3000 v1 build: {0}', github.event.inputs.openwrt_version)
      || (github.event_name == 'schedule'
          && 'TR3000 v1 build: latest stable (auto-detect)'
          || 'TR3000 v1 build') }}

on:
  workflow_dispatch:
    inputs:
      openwrt_version:
        description: 'OpenWrt git ref to checkout (tag/branch/commit), e.g. v24.10.5'
        required: true
        default: 'v24.10.5'
      clean_build:
        description: 'Force clean build (ignore cache)'
        required: false
        default: 'false'
        type: boolean
  push:
    branches: [ main ]
  schedule:
    # 每周日凌晨2点自动构建（可选）
    - cron: '0 2 * * 0'

jobs:
  precheck:
    runs-on: ubuntu-22.04
    outputs:
      openwrt_version: ${{ steps.out.outputs.openwrt_version }}
      should_build: ${{ steps.out.outputs.should_build }}
      reason: ${{ steps.out.outputs.reason }}
    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Determine OpenWrt version and decide whether to build
      id: setvars
      env:
        DEFAULT_VERSION: v24.10.5
        REQUESTED_VERSION: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.openwrt_version || '' }}
      run: |
        set -euo pipefail

        echo "Event: $GITHUB_EVENT_NAME"

        VERSION=""
        REASON=""

        if [ "$GITHUB_EVENT_NAME" = "workflow_dispatch" ] && [ -n "${REQUESTED_VERSION}" ]; then
          VERSION="${REQUESTED_VERSION}"
          REASON="workflow_dispatch: requested ${VERSION}"
        elif [ "$GITHUB_EVENT_NAME" = "schedule" ]; then
          echo "Checking upstream tags for latest stable version..."
          VERSION=$(git ls-remote --tags --refs https://github.com/openwrt/openwrt.git 'v*' \
            | awk '{print $2}' \
            | sed 's|refs/tags/||' \
            | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' \
            | sort -V \
            | tail -n 1 || true)
          if [ -z "$VERSION" ]; then
            VERSION="${DEFAULT_VERSION}"
            REASON="schedule: failed to detect latest stable tag; fallback ${VERSION}"
          else
            REASON="schedule: latest stable tag is ${VERSION}"
          fi
        else
          VERSION="${DEFAULT_VERSION}"
          REASON="${GITHUB_EVENT_NAME}: default ${VERSION}"
        fi

        echo "Selected OpenWrt version: ${VERSION}"
        echo "Reason: ${REASON}"

        # For scheduled runs: skip build if this version was already built.
        SHOULD_BUILD="true"
        if [ "$GITHUB_EVENT_NAME" = "schedule" ]; then
          MARKER_DIR=".build-markers/${VERSION}"
          mkdir -p "$MARKER_DIR"
          if [ -f "${MARKER_DIR}/built.txt" ]; then
            echo "Marker already present in workspace (unexpected)."
          fi
          echo "marker_dir=${MARKER_DIR}" >> "$GITHUB_OUTPUT"
        fi

        echo "openwrt_version=${VERSION}" >> "$GITHUB_OUTPUT"
        echo "reason=${REASON}" >> "$GITHUB_OUTPUT"
        echo "should_build=${SHOULD_BUILD}" >> "$GITHUB_OUTPUT"

    - name: Restore build marker cache (schedule only)
      if: github.event_name == 'schedule'
      id: marker
      uses: actions/cache@v4
      with:
        path: .build-markers/${{ steps.setvars.outputs.openwrt_version }}
        key: openwrt-tr3000-v1-built-${{ steps.setvars.outputs.openwrt_version }}

    - name: Finalize decision (schedule only)
      if: github.event_name == 'schedule'
      id: finalize
      run: |
        set -euo pipefail
        if [ "${{ steps.marker.outputs.cache-hit }}" = "true" ]; then
          echo "Cache marker hit: already built ${{ steps.setvars.outputs.openwrt_version }}"
          echo "should_build=false" >> "$GITHUB_OUTPUT"
        else
          echo "No marker cache: will build ${{ steps.setvars.outputs.openwrt_version }}"
          echo "should_build=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Publish final outputs
      id: out
      run: |
        set -euo pipefail
        # Default should_build=true (non-schedule); for schedule, override from finalize.
        SHOULD_BUILD="${{ steps.setvars.outputs.should_build }}"
        if [ "$GITHUB_EVENT_NAME" = "schedule" ]; then
          SHOULD_BUILD="${{ steps.finalize.outputs.should_build || 'true' }}"
        fi
        echo "openwrt_version=${{ steps.setvars.outputs.openwrt_version }}" >> "$GITHUB_OUTPUT"
        echo "should_build=${SHOULD_BUILD}" >> "$GITHUB_OUTPUT"
        echo "reason=${{ steps.setvars.outputs.reason }}" >> "$GITHUB_OUTPUT"

  build:
    name: Build firmware (${{ needs.precheck.outputs.openwrt_version }})
    needs: precheck
    if: needs.precheck.outputs.should_build == 'true'
    timeout-minutes: 360  # 6小时超时
    runs-on: ubuntu-22.04
    env:
      OPENWRT_VERSION: ${{ needs.precheck.outputs.openwrt_version }}
      CLEAN_BUILD: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.clean_build || false }}

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4
      with:
        path: 'config-repo'  # 分离配置和源码目录
    
    - name: Free disk space
      run: |
        echo "清理磁盘空间..."
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /opt/ghc
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /usr/local/lib/node_modules
        sudo apt clean
        df -h
    
    - name: Install dependencies
      run: |
        echo "安装编译依赖..."
        sudo apt update
        sudo apt install -y \
          build-essential clang flex bison g++ gawk gcc-multilib \
          gettext git libncurses-dev libssl-dev python3-setuptools \
          rsync unzip zlib1g-dev file wget python3-distutils \
          subversion quilt
        echo "依赖安装完成"
    
    - name: Clone OpenWrt
      run: |
        echo "克隆 OpenWrt 源码 ($OPENWRT_VERSION)..."
        # 使用浅克隆加速
        git clone --depth 1 --branch "$OPENWRT_VERSION" https://github.com/openwrt/openwrt.git
        cd openwrt
        # 如果是标签，获取完整历史以便打补丁
        if git describe --tags --exact-match "$OPENWRT_VERSION" 2>/dev/null; then
          echo "检测到标签版本，获取完整提交历史..."
          git fetch --unshallow
        fi
        echo "源码克隆完成"
    
    - name: Cache feeds and dl
      id: cache-feeds
      uses: actions/cache@v4
      with:
        path: |
          openwrt/feeds
          openwrt/dl
        # 关键修复：在key中加入源文件哈希，避免源切换时的缓存混淆
        key: ${{ runner.os }}-openwrt-${{ env.OPENWRT_VERSION }}-${{ env.CLEAN_BUILD == 'true' && 'clean' || hashFiles('config-repo/config/tr3000-v1.config', 'openwrt/feeds.conf.default') }}
        restore-keys: |
          ${{ runner.os }}-openwrt-${{ env.OPENWRT_VERSION }}-
        # 缓存控制
        enableCrossOsArchive: false
    
    - name: Apply DTS patch (safe edit)
      run: |
        set -euo pipefail
        cd openwrt
        
        DTS_FILE="target/linux/mediatek/dts/mt7981b-cudy-tr3000-v1.dts"
        OLD_LINE='reg = <0x5c0000 0x4000000>;'
        # 关键修复：修正重复的 "reg ="
        NEW_LINE='reg = <0x5c0000 0x7000000>;'
        
        echo "检查并应用 DTS 补丁..."
        test -f "$DTS_FILE"
        
        # 检查是否已打补丁
        if grep -qF "$NEW_LINE" "$DTS_FILE"; then
          echo "✓ DTS 已正确打补丁: $DTS_FILE"
          exit 0
        fi
        
        # 验证原行存在且唯一
        COUNT_OLD=$(grep -cF "$OLD_LINE" "$DTS_FILE" || true)
        if [ "$COUNT_OLD" -ne 1 ]; then
          echo "错误: 期望找到1处: $OLD_LINE"
          echo "实际找到: $COUNT_OLD 处"
          echo "拒绝打补丁 (上游 DTS 可能已变更)。"
          exit 1
        fi
        
        # 创建备份并应用补丁
        cp "$DTS_FILE" "${DTS_FILE}.bak"
        sed -i "s|$OLD_LINE|$NEW_LINE|" "$DTS_FILE"
        
        # 验证补丁结果
        if ! grep -qF "$NEW_LINE" "$DTS_FILE"; then
          echo "错误: 补丁失败 - 新行未找到"
          exit 1
        fi
        
        if grep -qF "$OLD_LINE" "$DTS_FILE"; then
          echo "错误: 补丁失败 - 旧行仍然存在"
          exit 1
        fi
        
        echo "✓ DTS 补丁应用成功: $DTS_FILE"
        echo "修改内容:"
        grep -E 'reg = <0x5c0000 0x[0-9a-fA-F]+>;' "$DTS_FILE"
    
    - name: Update feeds
      run: |
        set -euo pipefail
        cd openwrt
        
        # 备份原始配置
        cp -f feeds.conf.default feeds.conf.default.bak
        
        # 增强的重试函数（指数退避）
        retry() {
          local -r max_attempts="$1"
          local attempt=1
          local delay=10
          local last_exit_code=0
          
          shift
          
          until "$@"; do
            last_exit_code=$?
            if [ "$attempt" -ge "$max_attempts" ]; then
              echo "错误: 命令在 $max_attempts 次尝试后仍失败"
              return $last_exit_code
            fi
            echo "命令失败 (尝试 $attempt/$max_attempts)。${delay}秒后重试..."
            sleep "$delay"
            attempt=$((attempt + 1))
            delay=$((delay * 2))
          done
        }
        
        echo "开始更新 feeds..."
        
        # 先尝试官方源
        if retry 3 ./scripts/feeds update -a; then
          echo "✓ 官方源更新成功"
        else
          echo "官方源失败，切换到 GitHub 镜像..."
          
          # 切换到 GitHub 镜像源
          sed -i \
            -e 's|https://git\.openwrt\.org/|https://github.com/openwrt/|g' \
            -e 's|git://git\.openwrt\.org/|https://github.com/openwrt/|g' \
            feeds.conf.default
          
          # 清除 feeds 目录（保留 .index 文件）
          find feeds/ -mindepth 1 -maxdepth 1 -type d -exec rm -rf {} + 2>/dev/null || true
          
          # 使用镜像源重试
          echo "使用 GitHub 镜像重试..."
          if retry 5 ./scripts/feeds update -a; then
            echo "✓ GitHub 镜像更新成功"
          else
            echo "错误: 所有 feed 源均失败"
            exit 1
          fi
        fi
        
        # 安装 feeds
        echo "安装 feeds..."
        retry 3 ./scripts/feeds install -a
        echo "✓ Feeds 更新安装完成"
        
        # 显示 feeds 状态
        FEEDS_LIST_FILE="/tmp/openwrt-feeds-list.txt"
        ./scripts/feeds list > "$FEEDS_LIST_FILE"
        head -20 "$FEEDS_LIST_FILE"
        echo "... (共 $(wc -l < "$FEEDS_LIST_FILE") 个包)"
    
    - name: Apply config
      run: |
        cd openwrt
        echo "应用配置文件..."

        # 应用 rootfs overlay（用于默认配置/脚本）
        if [ -d "../config-repo/overlay" ]; then
          echo "应用 overlay: ../config-repo/overlay -> openwrt/files/"
          mkdir -p files
          rsync -a "../config-repo/overlay/" "files/"
        else
          echo "未发现 overlay 目录，跳过"
        fi
        
        # 检查配置文件是否存在
        if [ ! -f "../config-repo/config/tr3000-v1.config" ]; then
          echo "错误: 配置文件未找到: ../config-repo/config/tr3000-v1.config"
          exit 1
        fi
        
        echo "配置文件路径: ../config-repo/config/tr3000-v1.config"
        echo "配置文件哈希:"
        sha256sum "../config-repo/config/tr3000-v1.config" || true
        echo "配置文件中的 TARGET/DEVICE 行:"
        grep -nE '^CONFIG_TARGET_.*(=y|=m|=".*")$' "../config-repo/config/tr3000-v1.config" || true

        cp "../config-repo/config/tr3000-v1.config" .config

        echo "设备配置 (拷贝 config 后, defconfig 前):"
        grep -E '^CONFIG_TARGET_.*_DEVICE_.*=y' .config || true

        make defconfig

        echo ""
        echo "=== 严格模式校验: defconfig 后必须保留的配置项 ==="
        REQUIRED_CFG=(
          CONFIG_PACKAGE_kmod-nft-tproxy
          CONFIG_PACKAGE_kmod-nft-socket
          CONFIG_PACKAGE_block-mount
          CONFIG_PACKAGE_kmod-usb2
          CONFIG_PACKAGE_kmod-usb3
          CONFIG_PACKAGE_kmod-usb-storage
          CONFIG_PACKAGE_kmod-usb-storage-uas
          CONFIG_PACKAGE_kmod-scsi-core
          CONFIG_PACKAGE_kmod-scsi-generic

          # USB 网络共享 (手机/随身 WiFi USB 共享)
          CONFIG_PACKAGE_kmod-usb-net
          CONFIG_PACKAGE_kmod-usb-net-rndis
          CONFIG_PACKAGE_kmod-usb-net-ipheth
          CONFIG_PACKAGE_kmod-usb-net-cdc-ether
          CONFIG_PACKAGE_kmod-usb-net-cdc-ncm

          # USB 4G/5G 上网卡/随身 WiFi (核心: QMI/MBIM)
          CONFIG_PACKAGE_kmod-usb-wdm
          CONFIG_PACKAGE_kmod-usb-net-qmi-wwan
          CONFIG_PACKAGE_uqmi
          CONFIG_PACKAGE_kmod-usb-net-cdc-mbim
          CONFIG_PACKAGE_umbim

          CONFIG_PACKAGE_kmod-fs-ext4
          CONFIG_PACKAGE_kmod-fs-vfat
          CONFIG_PACKAGE_kmod-nls-cp437
          CONFIG_PACKAGE_kmod-nls-iso8859-1
          CONFIG_PACKAGE_kmod-nls-utf8
          CONFIG_PACKAGE_kmod-fs-exfat
          CONFIG_PACKAGE_kmod-fs-ntfs3

          # Samba 网盘共享（SMB3 加密）
          CONFIG_PACKAGE_samba4-server
          CONFIG_PACKAGE_luci-app-samba4

          # 安全远程访问（推荐）：WireGuard VPN
          CONFIG_PACKAGE_kmod-wireguard
          CONFIG_PACKAGE_wireguard-tools
          CONFIG_PACKAGE_luci-proto-wireguard
        )

        # 可选项：缺失不致命（仅提示），用于增强体验/工具
        OPTIONAL_CFG=(
          CONFIG_PACKAGE_luci-app-mount
          CONFIG_PACKAGE_e2fsprogs
          CONFIG_PACKAGE_exfatprogs

          # Samba 体验增强
          CONFIG_PACKAGE_wsdd2
          CONFIG_PACKAGE_shadow-useradd

          # USB 4G/5G 体验增强 (LuCI 协议支持)
          CONFIG_PACKAGE_luci-proto-qmi
          CONFIG_PACKAGE_luci-proto-mbim

          # 兼容少数老式拨号棒 (PPP over USB-Serial)
          CONFIG_PACKAGE_kmod-usb-serial
          CONFIG_PACKAGE_kmod-usb-serial-wwan
          CONFIG_PACKAGE_kmod-usb-serial-option
          CONFIG_PACKAGE_kmod-usb-serial-qcserial
          CONFIG_PACKAGE_kmod-usb-serial-sierra
          CONFIG_PACKAGE_ppp
          CONFIG_PACKAGE_chat
        )

        MISSING=0
        for k in "${REQUIRED_CFG[@]}"; do
          if ! grep -qE "^${k}=y$" .config; then
            echo "✗ 缺失或未内置: ${k} (期望: ${k}=y)"
            MISSING=1
          fi
        done

        for k in "${OPTIONAL_CFG[@]}"; do
          if ! grep -qE "^${k}=y$" .config; then
            echo "! 可选项未内置: ${k} (期望: ${k}=y；但缺失不会阻断构建)"
          fi
        done
        if [ "$MISSING" -ne 0 ]; then
          echo ""
          echo "错误: 严格模式校验失败：defconfig 后配置项未按预期保留。"
          echo "提示: 包名可能写错/版本不包含/依赖不满足，或被 Kconfig 自动降级。"
          echo ""
          echo "=== 诊断信息: .config 中的实际值 ==="
          for k in "${REQUIRED_CFG[@]}" "${OPTIONAL_CFG[@]}"; do
            if grep -qE "^${k}=" .config; then
              grep -E "^${k}=" .config || true
            else
              echo "${k} is absent from .config"
            fi
          done

          echo ""
          echo "=== 诊断信息: Kconfig 符号是否存在 (tmp/.config-package.in) ==="
          if [ -f tmp/.config-package.in ]; then
            for k in "${REQUIRED_CFG[@]}" "${OPTIONAL_CFG[@]}"; do
              sym="${k#CONFIG_}"
              # tmp/.config-package.in 可能包含额外空格或 CRLF，避免使用严格行尾匹配
              if grep -qE "^config[[:space:]]+${sym}([[:space:]]|\r|$)" tmp/.config-package.in; then
                echo "✓ present: ${k} (config ${sym})"
              else
                echo "✗ missing: ${k} (config ${sym})  -> 可能是包在该版本/feeds 中不存在或未正确安装 feeds"
              fi
            done
          else
            echo "未找到 tmp/.config-package.in (feeds 未生成/目录结构变化/defconfig 前置步骤异常)"
          fi

          echo ""
          echo "=== 诊断信息: diffconfig (defconfig 后与默认差异) ==="
          if [ -x ./scripts/diffconfig.sh ]; then
            ./scripts/diffconfig.sh | grep -E '^(CONFIG_PACKAGE_(kmod-nft-tproxy|kmod-nft-socket|block-mount|luci-app-mount|kmod-usb2|kmod-usb3|kmod-usb-storage|kmod-usb-storage-uas|kmod-scsi-core|kmod-scsi-generic|kmod-usb-net|kmod-usb-net-rndis|kmod-usb-net-ipheth|kmod-usb-net-cdc-ether|kmod-usb-net-cdc-ncm|kmod-usb-wdm|kmod-usb-net-qmi-wwan|uqmi|luci-proto-qmi|kmod-usb-net-cdc-mbim|umbim|luci-proto-mbim|kmod-usb-serial|kmod-usb-serial-wwan|kmod-usb-serial-option|kmod-usb-serial-qcserial|kmod-usb-serial-sierra|ppp|chat|kmod-fs-ext4|e2fsprogs|kmod-fs-vfat|kmod-nls-cp437|kmod-nls-iso8859-1|kmod-nls-utf8|kmod-fs-exfat|exfatprogs|kmod-fs-ntfs3|samba4-server|luci-app-samba4|wsdd2|shadow-useradd|kmod-wireguard|wireguard-tools|luci-proto-wireguard))' || true
          else
            echo "scripts/diffconfig.sh 不存在或不可执行"
          fi
          exit 1
        fi
        echo "✓ 严格模式校验通过: defconfig 后关键包均为 =y"

        echo "设备配置 (defconfig 后):"
        grep -E '^CONFIG_TARGET_.*_DEVICE_.*=y' .config || true

        # 严格匹配：必须是 cudy_tr3000-v1（非 ubootmod），避免落到默认 abt_asr3000
        if ! grep -qF 'CONFIG_TARGET_mediatek_filogic_DEVICE_cudy_tr3000-v1=y' .config; then
          echo "错误: 目标设备未正确选中: 期望 CONFIG_TARGET_mediatek_filogic_DEVICE_cudy_tr3000-v1=y"
          echo "实际设备选择如下:"
          grep -E '^CONFIG_TARGET_.*_DEVICE_.*=y' .config || true

          echo ""
          echo "调试: 期望的 Kconfig 条目是否存在 (tmp/.config-target.in)?"
          if [ -f tmp/.config-target.in ]; then
            echo "--- grep cudy_tr3000 ---"
            grep -nE 'cudy_tr3000' tmp/.config-target.in || true
            echo "--- grep abt_asr3000 ---"
            grep -nE 'abt_asr3000' tmp/.config-target.in || true
            echo "--- grep TARGET_mediatek_filogic_DEVICE_cudy_tr3000-v1 ---"
            grep -nE 'TARGET_mediatek_filogic_DEVICE_cudy_tr3000-v1' tmp/.config-target.in || true
          else
            echo "未找到 tmp/.config-target.in (make defconfig 未生成? 或目录结构变更)"
            ls -la tmp || true
          fi
          exit 1
        fi

        if grep -qE '^CONFIG_TARGET_.*_DEVICE_.*ubootmod.*=y$' .config; then
          echo "错误: 检测到 ubootmod 变体被选中，但该工作流期望生成官方同款 sysupgrade.bin。"
          grep -E '^CONFIG_TARGET_.*_DEVICE_.*ubootmod.*=y$' .config || true
          exit 1
        fi
        
        # 验证配置
        echo "当前配置摘要:"
        echo "目标: $(grep '^CONFIG_TARGET_[^=]*=y' .config | head -5)"
        echo "架构: $(grep '^CONFIG_TARGET_ARCH_PACKAGES' .config)"
        echo "启用的包数量: $(grep -c '^CONFIG_PACKAGE_' .config)"
    
    - name: Download sources
      run: |
        set -euo pipefail
        cd openwrt
        echo "下载源代码..."
        
        # 检查网络连接
        if ! curl -s --connect-timeout 10 https://github.com > /dev/null; then
          echo "警告: 网络连接可能不稳定"
        fi
        
        # 下载源码，带重试
        retry_download() {
          local attempt=1
          while [ $attempt -le 3 ]; do
            make download -j"$(nproc)" 2>&1 | tee download.log
            status=${PIPESTATUS[0]}
            if [ "$status" -eq 0 ]; then
              echo "✓ 源代码下载成功"
              return 0
            fi
            echo "下载失败，尝试 $attempt/3..."
            attempt=$((attempt + 1))
            sleep 30
          done
          return 1
        }
        
        retry_download
        
        # 备注：OpenWrt 的 scripts/download.pl 没有 `check` 子命令；完整性校验由 `make download` 过程本身完成。
    
    - name: Build firmware
      run: |
        cd openwrt
        echo "开始编译固件..."
        echo "开始时间: $(date)"
        
        # 记录构建信息
        echo "构建环境信息:"
        echo "- CPU: $(nproc) 核心"
        echo "- 内存: $(free -h | awk '/^Mem:/ {print $2}')"
        echo "- 磁盘空间:"
        df -h .
        
        # 主构建过程
        BUILD_LOG="build.log"
        if ! make -j$(($(nproc) + 1)) V=s 2>&1 | tee "$BUILD_LOG"; then
          echo "编译失败，尝试单线程调试构建..."
          DEBUG_LOG="build-debug.log"
          # 单线程详细输出
          make -j1 V=sc 2>&1 | tee "$DEBUG_LOG"
          
          # 提取错误信息
          echo "=== 构建失败分析 ==="
          tail -100 "$DEBUG_LOG" | grep -i "error\|failed\|undefined"
          
          # 保存调试日志
          echo "构建日志已保存: $BUILD_LOG, $DEBUG_LOG"
          exit 1
        fi
        
        echo "✓ 固件编译成功"
        echo "结束时间: $(date)"
        
        # 计算构建时间
        echo "构建耗时: $((SECONDS / 60)) 分钟 $((SECONDS % 60)) 秒"

    - name: Validate image content and report size (strict)
      run: |
        set -euo pipefail
        cd openwrt

        echo "=== 严格模式校验: 镜像内容 (manifest) ==="
        MANIFEST=""
        MANIFEST=$(ls -1 bin/targets/mediatek/filogic/*.manifest 2>/dev/null | head -n 1 || true)
        if [ -z "$MANIFEST" ] || [ ! -f "$MANIFEST" ]; then
          echo "错误: 未找到 manifest 文件: bin/targets/mediatek/filogic/*.manifest"
          find bin/targets/mediatek/filogic/ -maxdepth 1 -type f -print || true
          exit 1
        fi
        echo "使用 manifest: $MANIFEST"

        REQUIRED_PKGS=(
          kmod-nft-tproxy
          kmod-nft-socket
          block-mount
          kmod-usb2
          kmod-usb3
          kmod-usb-storage
          kmod-usb-storage-uas
          kmod-scsi-core
          kmod-scsi-generic

          # USB 网络共享 (手机/随身 WiFi USB 共享)
          kmod-usb-net
          kmod-usb-net-rndis
          kmod-usb-net-ipheth
          kmod-usb-net-cdc-ether
          kmod-usb-net-cdc-ncm

          # USB 4G/5G 上网卡/随身 WiFi (核心: QMI/MBIM)
          kmod-usb-wdm
          kmod-usb-net-qmi-wwan
          uqmi
          kmod-usb-net-cdc-mbim
          umbim

          kmod-fs-ext4
          kmod-fs-vfat
          kmod-nls-cp437
          kmod-nls-iso8859-1
          kmod-nls-utf8
          kmod-fs-exfat
          kmod-fs-ntfs3

          # Samba 网盘共享（SMB3 加密）
          samba4-server
          luci-app-samba4

          # 安全远程访问（推荐）：WireGuard VPN
          kmod-wireguard
          wireguard-tools
          luci-proto-wireguard
        )

        OPTIONAL_PKGS=(
          luci-app-mount
          e2fsprogs
          exfatprogs

          # Samba 体验增强
          wsdd2
          shadow-useradd

          # USB 4G/5G 体验增强 (LuCI 协议支持)
          luci-proto-qmi
          luci-proto-mbim

          # 兼容少数老式拨号棒 (PPP over USB-Serial)
          kmod-usb-serial
          kmod-usb-serial-wwan
          kmod-usb-serial-option
          kmod-usb-serial-qcserial
          kmod-usb-serial-sierra
          ppp
          chat
        )

        MISSING=0
        for p in "${REQUIRED_PKGS[@]}"; do
          if ! grep -qE "^${p} " "$MANIFEST"; then
            echo "✗ 镜像未包含: ${p} (manifest 中未找到)"
            MISSING=1
          fi
        done
        if [ "$MISSING" -ne 0 ]; then
          echo ""
          echo "错误: 严格模式校验失败：镜像 manifest 未包含全部必需包。"
          echo "调试: 以下是 manifest 中相关条目(若有):"
          grep -E '^(kmod-nft-tproxy|kmod-nft-socket|block-mount|luci-app-mount|kmod-usb|kmod-scsi|kmod-fs-|kmod-nls-|e2fsprogs|exfatprogs) ' "$MANIFEST" || true
          exit 1
        fi
        echo "✓ 严格模式校验通过: manifest 包含全部必需包"

        for p in "${OPTIONAL_PKGS[@]}"; do
          if ! grep -qE "^${p} " "$MANIFEST"; then
            echo "! 可选包未进镜像: ${p} (不阻断构建)"
          fi
        done

        echo ""
        echo "=== 体积报告: 固件与 rootfs ==="
        ls -lh bin/targets/mediatek/filogic/ || true
        SYSUP=""
        SYSUP=$(ls -1 bin/targets/mediatek/filogic/*sysupgrade*.bin 2>/dev/null | head -n 1 || true)
        if [ -n "$SYSUP" ] && [ -f "$SYSUP" ]; then
          echo "sysupgrade.bin: $(ls -lh "$SYSUP")"
        else
          echo "未找到 sysupgrade.bin (用于体积参考)"
        fi

        ROOTFS=""
        ROOTFS=$(ls -1 bin/targets/mediatek/filogic/*rootfs*.squashfs 2>/dev/null | head -n 1 || true)
        if [ -n "$ROOTFS" ] && [ -f "$ROOTFS" ]; then
          echo "rootfs.squashfs: $(ls -lh "$ROOTFS")"
        else
          echo "未找到 rootfs.squashfs (不同 target 可能不输出该文件)"
        fi

        echo ""
        echo "=== 体积估算: 相关包 ipk 文件大小 (压缩包，仅供估算) ==="
        total=0
        for p in "${REQUIRED_PKGS[@]}" "${OPTIONAL_PKGS[@]}"; do
          ipk=$(find bin -type f -name "${p}_*.ipk" 2>/dev/null | head -n 1 || true)
          if [ -n "$ipk" ] && [ -f "$ipk" ]; then
            sz=$(stat -c '%s' "$ipk")
            total=$((total + sz))
            echo "$(printf '%-22s' "$p"): $(numfmt --to=iec --suffix=B "$sz")  ($ipk)"
          else
            echo "$(printf '%-22s' "$p"): (未找到对应 ipk，可能被内联到 target packages 或命名不同)"
          fi
        done
        echo "ipk 体积合计(上限估算): $(numfmt --to=iec --suffix=B "$total")"

    - name: Write and save build marker (schedule only)
      if: github.event_name == 'schedule'
      run: |
        set -euo pipefail
        cd "${GITHUB_WORKSPACE}"
        MARKER_DIR=".build-markers/${OPENWRT_VERSION}"
        mkdir -p "$MARKER_DIR"
        {
          echo "version=${OPENWRT_VERSION}"
          echo "run_id=${GITHUB_RUN_ID}"
          echo "sha=${GITHUB_SHA}"
          echo "built_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        } > "${MARKER_DIR}/built.txt"
        cat "${MARKER_DIR}/built.txt"

    - name: Save build marker cache (schedule only)
      if: github.event_name == 'schedule'
      uses: actions/cache@v4
      with:
        path: .build-markers/${{ env.OPENWRT_VERSION }}
        key: openwrt-tr3000-v1-built-${{ env.OPENWRT_VERSION }}

    - name: Collect artifacts
      run: |
        echo "收集构建产物..."
        mkdir -p output
        
        cd openwrt
        
        # 查找固件文件
        FIRMWARE_FILES=()
        while IFS= read -r file; do
          FIRMWARE_FILES+=("$file")
        done < <(
          find bin/targets/mediatek/filogic/ -type f \
            \( \
              -name "*sysupgrade*.bin" -o \
              -name "*sysupgrade*.itb" -o \
              -name "*sysupgrade*.tar" -o \
              -name "*sysupgrade*.img.gz" -o \
              -name "*factory*.bin" -o \
              -name "*factory*.img.gz" -o \
              -name "*.manifest" -o \
              -name "*.buildinfo" -o \
              -name "sha256sums" -o \
              -name "profiles.json" \
            \) 2>/dev/null || true
        )
        
        if [ ${#FIRMWARE_FILES[@]} -eq 0 ]; then
          echo "错误: 未找到固件文件"
          echo "目录内容:"
          find bin/targets/ -type f 2>/dev/null || ls -la bin/ 2>/dev/null || true
          exit 1
        fi

        # 期望产物包含官方同款 sysupgrade.bin（而不是仅有 sysupgrade.itb）
        if ! find bin/targets/mediatek/filogic/ -type f -name "*sysupgrade*.bin" | grep -q .; then
          echo "错误: 未找到 sysupgrade.bin 产物。"
          echo "提示: 如果只生成了 sysupgrade.itb，通常是选到了 *-ubootmod 变体或文件系统配置不匹配。"
          echo "当前目录下的 sysupgrade 相关文件:"
          find bin/targets/mediatek/filogic/ -type f -name "*sysupgrade*" -maxdepth 2 2>/dev/null || true
          exit 1
        fi
        
        # 复制文件
        for file in "${FIRMWARE_FILES[@]}"; do
          echo "复制: $file"
          cp "$file" ../output/
        done
        
        # 添加构建信息
        echo "生成构建信息..."
        {
          echo "构建日期: $(date)"
          echo "OpenWrt 版本: $OPENWRT_VERSION"
          echo "GitHub Actions Run: https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
          echo "触发事件: $GITHUB_EVENT_NAME"
          echo "提交: $GITHUB_SHA"
          echo "内核版本: $(grep '^Linux version' build.log | head -1 || echo '未知')"
          echo "固件文件:"
          ls -lh ../output/
        } > ../output/build-info.txt
        
        echo "✓ 产物收集完成"
        ls -lh ../output/

    - name: Prepare artifact info
      run: |
        set -euo pipefail
        TS="$(date +%Y%m%d-%H%M%S)"

        # 生成可追踪且真正动态的 artifact 名称（避免 $(date ...) 被当作字面量）
        echo "ARTIFACT_NAME=openwrt-${OPENWRT_VERSION}-tr3000-v1-${GITHUB_RUN_ID}-${TS}" >> "$GITHUB_ENV"
        echo "LOGS_ARTIFACT_NAME=build-logs-${OPENWRT_VERSION}-${GITHUB_RUN_ID}-${TS}" >> "$GITHUB_ENV"

        echo "即将上传的产物清单:"
        ls -lh output || true
        echo "文件数量: $(find output -maxdepth 1 -type f | wc -l)"
        echo "Artifact name: openwrt-${OPENWRT_VERSION}-tr3000-v1-${GITHUB_RUN_ID}-${TS}"
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: output/*
        retention-days: 30
        if-no-files-found: error
    
    - name: Upload build logs (on failure)
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.LOGS_ARTIFACT_NAME }}
        path: |
          openwrt/build.log
          openwrt/build-debug.log
          openwrt/download.log
        retention-days: 7
    
    - name: Cleanup workspace
      if: always()
      run: |
        echo "清理工作空间..."
        # 保留必要的产物和日志
        du -sh openwrt/ 2>/dev/null || true
        # 可选：移除源码节省空间
        # if [ "${{ github.event_name }}" != "schedule" ]; then
        #   rm -rf openwrt/
        # fi
        echo "工作流完成"

  skip:
    name: "Skip (already built: ${{ needs.precheck.outputs.openwrt_version }})"
    needs: precheck
    if: needs.precheck.outputs.should_build != 'true'
    runs-on: ubuntu-22.04
    steps:
    - name: Skip build (no new stable version)
      run: |
        echo "No new upstream stable version; skipping build."
        echo "Selected version: ${{ needs.precheck.outputs.openwrt_version }}"
        echo "Reason: ${{ needs.precheck.outputs.reason }}"